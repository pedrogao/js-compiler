use super::CodeGenerator;
use crate::ir::{BinaryOp, Constant, IRFunction, IRInstruction, IRModule, UnaryOp};
use std::collections::HashMap;
use std::fmt::Write;

pub struct X64Generator {
    output: String,
    string_literals: Vec<String>,
    float_literals: Vec<f64>,
    local_offsets: HashMap<String, i32>,
    current_stack_size: i32,
    label_counter: usize,
}

impl X64Generator {
    pub fn new() -> Self {
        Self {
            output: String::new(),
            string_literals: Vec::new(),
            float_literals: Vec::new(),
            local_offsets: HashMap::new(),
            current_stack_size: 0,
            label_counter: 0,
        }
    }

    fn reset_state(&mut self) {
        self.local_offsets.clear();
        self.current_stack_size = 0;
    }

    fn next_label(&mut self) -> String {
        self.label_counter += 1;
        format!(".L{}", self.label_counter)
    }

    fn generate_function(&mut self, function: &IRFunction) {
        self.reset_state();

        // Function header
        writeln!(self.output, "\t.globl {}", function.name).unwrap();
        writeln!(self.output, "\t.type {}, @function", function.name).unwrap();
        writeln!(self.output, "{}:", function.name).unwrap();

        // Function prologue
        writeln!(self.output, "\tpush %rbp").unwrap();
        writeln!(self.output, "\tmov %rsp, %rbp").unwrap();

        // Allocate stack frame
        let frame_size = ((function.max_locals * 8 + 15) / 16) * 16;
        if frame_size > 0 {
            writeln!(self.output, "\tsub ${}, %rsp", frame_size).unwrap();
        }

        // Save callee-saved registers
        writeln!(self.output, "\tpush %rbx").unwrap();
        writeln!(self.output, "\tpush %r12").unwrap();
        writeln!(self.output, "\tpush %r13").unwrap();
        writeln!(self.output, "\tpush %r14").unwrap();
        writeln!(self.output, "\tpush %r15").unwrap();

        // Move parameters to their slots
        for (i, param) in function.params.iter().enumerate() {
            let param_reg = match i {
                0 => "%rdi",
                1 => "%rsi",
                2 => "%rdx",
                3 => "%rcx",
                4 => "%r8",
                5 => "%r9",
                _ => panic!("Too many parameters"),
            };
            let offset = self.allocate_local(&param);
            writeln!(self.output, "\tmov {}, {}(%rbp)", param_reg, offset).unwrap();
        }

        // Generate code for each instruction
        for instruction in &function.instructions {
            self.generate_instruction(instruction);
        }

        // Function epilogue is generated by Return instruction
    }

    fn generate_epilogue(&mut self) {
        // Restore callee-saved registers
        writeln!(self.output, "\tpop %r15").unwrap();
        writeln!(self.output, "\tpop %r14").unwrap();
        writeln!(self.output, "\tpop %r13").unwrap();
        writeln!(self.output, "\tpop %r12").unwrap();
        writeln!(self.output, "\tpop %rbx").unwrap();
        writeln!(self.output, "\tmov %rbp, %rsp").unwrap();
        writeln!(self.output, "\tpop %rbp").unwrap();
        writeln!(self.output, "\tret").unwrap();
    }

    fn generate_instruction(&mut self, instruction: &IRInstruction) {
        match instruction {
            IRInstruction::PushConst(constant) => self.generate_push_const(constant),
            IRInstruction::Load(name) => self.generate_load(name),
            IRInstruction::Store(name) => self.generate_store(name),
            IRInstruction::Binary(op) => self.generate_binary_op(op),
            IRInstruction::Unary(op) => self.generate_unary_op(op),
            IRInstruction::Call(name, argc) => self.generate_call(name, *argc),
            IRInstruction::Return(has_value) => self.generate_return(*has_value),
            IRInstruction::Jump(label) => self.generate_jump(label),
            IRInstruction::JumpIf(label) => self.generate_jump_if(label),
            IRInstruction::Label(label) => writeln!(self.output, "{}:", label).unwrap(),
            IRInstruction::Pop => writeln!(self.output, "\tpop %rax").unwrap(),
            IRInstruction::Dup => {
                writeln!(self.output, "\tmov (%rsp), %rax").unwrap();
                writeln!(self.output, "\tpush %rax").unwrap();
            }
        }
    }

    fn allocate_local(&mut self, name: &str) -> i32 {
        let offset = self.current_stack_size - 8;
        self.local_offsets.insert(name.to_string(), offset);
        self.current_stack_size = offset;
        offset
    }

    fn generate_push_const(&mut self, constant: &Constant) {
        match constant {
            Constant::Number(n) => {
                let idx = self.float_literals.len();
                self.float_literals.push(*n);
                writeln!(self.output, "\tmovsd .LCD{}(%rip), %xmm0", idx).unwrap();
                writeln!(self.output, "\tpush %xmm0").unwrap();
            }
            Constant::String(s) => {
                let idx = self.string_literals.len();
                self.string_literals.push(s.clone());
                writeln!(self.output, "\tleaq .LC{}(%rip), %rax", idx).unwrap();
                writeln!(self.output, "\tpush %rax").unwrap();
            }
            Constant::Boolean(b) => {
                writeln!(self.output, "\tpush ${}", if *b { 1 } else { 0 }).unwrap();
            }
            Constant::Null => {
                writeln!(self.output, "\tpush $0").unwrap();
            }
        }
    }

    fn generate_load(&mut self, name: &str) {
        if let Some(&offset) = self.local_offsets.get(name) {
            writeln!(self.output, "\tmov {}(%rbp), %rax", offset).unwrap();
            writeln!(self.output, "\tpush %rax").unwrap();
        } else {
            // Global variable handling could be added here
            panic!("Undefined variable: {}", name);
        }
    }

    fn generate_store(&mut self, name: &str) {
        let offset = self.local_offsets.get(name).cloned().unwrap_or_else(|| {
            let offset = self.allocate_local(name);
            offset
        });
        writeln!(self.output, "\tpop %rax").unwrap();
        writeln!(self.output, "\tmov %rax, {}(%rbp)", offset).unwrap();
    }

    fn generate_binary_op(&mut self, op: &BinaryOp) {
        writeln!(self.output, "\tpop %rcx").unwrap(); // right operand
        writeln!(self.output, "\tpop %rax").unwrap(); // left operand

        match op {
            BinaryOp::Add => {
                writeln!(self.output, "\tadd %rcx, %rax").unwrap();
            }
            BinaryOp::Sub => {
                writeln!(self.output, "\tsub %rcx, %rax").unwrap();
            }
            BinaryOp::Mul => {
                writeln!(self.output, "\timul %rcx, %rax").unwrap();
            }
            BinaryOp::Div => {
                writeln!(self.output, "\tcqo").unwrap();
                writeln!(self.output, "\tidiv %rcx").unwrap();
            }
            BinaryOp::Eq | BinaryOp::Lt | BinaryOp::Gt | BinaryOp::Le | BinaryOp::Ge => {
                writeln!(self.output, "\tcmp %rcx, %rax").unwrap();
                let cmd = match op {
                    BinaryOp::Eq => "sete",
                    BinaryOp::Lt => "setl",
                    BinaryOp::Gt => "setg",
                    BinaryOp::Le => "setle",
                    BinaryOp::Ge => "setge",
                    _ => unreachable!(),
                };
                writeln!(self.output, "\t{} %al", cmd).unwrap();
                writeln!(self.output, "\tmovzx %al, %rax").unwrap();
            }
            BinaryOp::And => {
                writeln!(self.output, "\tand %rcx, %rax").unwrap();
            }
            BinaryOp::Or => {
                writeln!(self.output, "\tor %rcx, %rax").unwrap();
            }
        }
        writeln!(self.output, "\tpush %rax").unwrap();
    }

    fn generate_unary_op(&mut self, op: &UnaryOp) {
        writeln!(self.output, "\tpop %rax").unwrap();
        match op {
            UnaryOp::Neg => {
                writeln!(self.output, "\tneg %rax").unwrap();
            }
            UnaryOp::Not => {
                writeln!(self.output, "\tcmp $0, %rax").unwrap();
                writeln!(self.output, "\tsete %al").unwrap();
                writeln!(self.output, "\tmovzx %al, %rax").unwrap();
            }
        }
        writeln!(self.output, "\tpush %rax").unwrap();
    }

    fn generate_call(&mut self, name: &str, argc: u16) {
        // Align stack to 16 bytes (System V ABI requirement)
        let stack_adjustment = (argc as i32 * 8) & 15;
        if stack_adjustment > 0 {
            writeln!(self.output, "\tsub ${}, %rsp", 16 - stack_adjustment).unwrap();
        }

        // Set up arguments
        for i in (0..argc).rev() {
            let reg = match i {
                0 => "%rdi",
                1 => "%rsi",
                2 => "%rdx",
                3 => "%rcx",
                4 => "%r8",
                5 => "%r9",
                _ => panic!("Too many arguments in call to {}", name),
            };
            writeln!(self.output, "\tpop {}", reg).unwrap();
        }

        writeln!(self.output, "\tcall {}", name).unwrap();

        // Clean up stack if needed
        if stack_adjustment > 0 {
            writeln!(self.output, "\tadd ${}, %rsp", 16 - stack_adjustment).unwrap();
        }

        // Push return value
        writeln!(self.output, "\tpush %rax").unwrap();
    }

    fn generate_return(&mut self, has_value: bool) {
        if has_value {
            writeln!(self.output, "\tpop %rax").unwrap();
        }
        self.generate_epilogue();
    }

    fn generate_jump(&mut self, label: &str) {
        writeln!(self.output, "\tjmp {}", label).unwrap();
    }

    fn generate_jump_if(&mut self, label: &str) {
        writeln!(self.output, "\tpop %rax").unwrap();
        writeln!(self.output, "\tcmp $0, %rax").unwrap();
        writeln!(self.output, "\tjne {}", label).unwrap();
    }
}

impl CodeGenerator for X64Generator {
    fn generate(&mut self, module: IRModule) -> String {
        // Data section for constants
        writeln!(self.output, "\t.section .data").unwrap();

        // Add string literals
        for (i, s) in self.string_literals.iter().enumerate() {
            writeln!(self.output, ".LC{}:", i).unwrap();
            writeln!(self.output, "\t.string \"{}\"", s).unwrap();
        }

        // Add float literals
        for (i, f) in self.float_literals.iter().enumerate() {
            writeln!(self.output, ".LCD{}:", i).unwrap();
            writeln!(self.output, "\t.double {}", f).unwrap();
        }

        // Text section for code
        writeln!(self.output, "\t.section .text").unwrap();

        // Generate code for each function
        for function in module.functions {
            self.generate_function(&function);
        }

        // Return the generated assembly
        self.output.clone()
    }
}
